### Коллекции

Коллекция в Python &mdash; программный объект (переменная-контейнер), хранящая набор значений одного или различных типов. 

**Простым языком**, коллекция &mdash; это хранилище информации, каталог построенный по какому-то принципу.

Хранилища бывают разными: может быть мешок из которого ты достаешь содержимое наугад, может быть разложенный по 
алфавиту каталог в котором очень легко что-то найти или труба из которой можно достать только то, что лежит с краю и т.п.

В зависимости от целей можно и нужно применять различные коллекции. Например, чтобы быстро найти что-то используют 
словари; для хранения упорядоченных данных, когда порядок имеет значение &mdash; списки и кортежи; для хранения только
уникальных элементов &mdash; множества; для хранения символов &mdash; строки и т.п.

В этом уроке мы выучим основные коллекции Python и научимся работать с ними. Это основа языка и знание возможностей
коллекций является не только очень полезным навыком, но и определяющим для разработчика на Python.

Основные свойства коллекций:

* Упорядоченность. Упорядоченный контейнер (коллекция) дает возможность обращаться к своим элементам по индексу (номеру)
    и гарантирует, что порядок элементов сохраняется.
* Изменяемость. Если коллекция изменяемая, то её содержимое можно изменять не создавая новую коллекцию. Например 
    добавлять, удалять, заменять элементы коллекции.
* Уникальность. Уникальность касается содержимого коллекции, допускается ли хранения одинаковых объектов.

## Списки

Список &mdash; __упорядоченный изменяемый__ контейнер данных. 
Списки не диктуют разработчику тип данных, который можно поместить в этот контейнер и могут содержать любые типы данных в любом удобном порядке.

Для создания пустого списка есть два способа:
```python
my_list = list()

empty_list = []
```

Чтобы создать заполненный список:
```python
not_empty = [1, 2, 'user']
```

### Упорядоченные контейнеры

#### Доступ по индексу

Под упорядоченностью следует понимать свойство контейнера сохранять порядок элементов при работе с ним, удаляя элемент, 
добавляя новый делая вставку/удаление с конца/начала/средины вы гарантируете что все элементы кроме тех, 
которых непосредственно коснулась операция, сохраняют порядок.

Самым полезным свойством упорядоченности является возможность доступа к элементам контейнера по индексу
этого элемента в контейнере.

В Python синтаксис доступа по индексу выглядит так:
```python
some_iterable = ["a", "b", "c"]
first_letter = some_iterable[0]
middle_one = some_iterable[1]
last_letter = some_iterable[2]
```

В первой строке мы создали список из трёх первых букв английского алфавита. 

Во второй стоке мы сохранили в переменную `first_letter` букву `"a"`, первый элемент `some_iterable`. 
__Индекс__ в Python начинается с `0`, как и в большинстве языков программирования и индексом `"a"` есть `0`. 

Третья строка &mdash; это обращение ко второму элементу `some_iterable`, его индекс равен `1` &mdash; это буква `"b"` и мы сохраняем её в `middle_one`.

Четвертая строка &mdash; это обращение к последнему элементу `some_iterable`, букве `"c"`, мы сохраним её в `last_letter` и её индекс равен `2`.

Python поддерживает индексирование элементов с конца. Для этого надо добавить `-` и указать номер элемента с конца.
Поскольку в Python `-0 == 0`, то первый элемент с конца &mdash; это `-1`, второй &mdash; `-2` и так далее. 
Наш пример можно переписать используя индексирование с конца вот так:
```python
some_iterable = ["a", "b", "c"]
first_letter = some_iterable[-3]
middle_one = some_iterable[-2]
last_letter = some_iterable[-1]
```

Самым полезным свойством списков является изменяемость списков, вы можете поменять значение любого элемента списка:
```python
some_iterable = ["a", "b", "c"]
some_iterable[1] = "Z"
print(some_iterable)    # ["a", "Z", "c"]
```

В этом примере мы поменяли второй элемент списка `some_iterable` (второй элемент &mdash; это элемент с индексом 1) на `'Z'`.
#### Срезы в Python (Slice)

Для упорядоченных контейнеров есть специальный синтаксис когда нам необходимо получить некоторую последовательность элементов из контейнера.
Например, если мы хотим получить первые 5 букв строки:

```python
some_str = "This is awesome string"
first_five = some_str[0:5]
```

`first_five` в этом примере будет содержать строку `'This '`.

Синтаксис состоит в указании индекса первого элемента среза, 
индекса до которого (не включительно) брать элементы в новую последовательность 
и шага с которым брать элементы между начальным и конечным индексом в квадратных скобках разделив их двоеточием.

Давайте возьмем список чисел от 1 до 10 и сохраним отдельно парные, непарные и кратные 3.

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

odd_numbers = [0:10:2]
even_numbers = [1:10:2]
three_numbers = [2:10:3]
```

В `odd_numbers` мы берем числа начиная с индекса 0 до 10 с шагом в 2 (получим `[1, 3, 5, 7, 9]`).
В `even_numbers` мы берем числа начиная с индекса 1 до 10 с шагом в 2 (получим `[2, 4, 6, 8]`).
В `three_numbers` мы берем числа начиная с индекса 2 до 10 с шагом в 3 (получим `[3, 6, 9]`).

Вы можете не указывать начальный, конечный индекс или шаг пропуская его. По умолчанию Python возьмет срез с начала и до последнего элемента с шагом в 1.
Перепишем предыдущий пример в сокращенном синтаксисе:

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

odd_numbers = [::2]
even_numbers = [1::2]
three_numbers = [2:10:3]

numbers_copy = numbers[:]
```

`numbers_copy` в этом примере &mdash; это срез, который берет все элементы `numbers` от начала и до конца с шагом 1.

Также важно помнить, что в срез не входит элемент с индексом до которого брать элементы.

```python
numbers = [0, 1, 2, 3]
first_three = numbers[0:3]  # [0, 1, 2]
```

В этом примере элемент с индексом 3 не войдет в `first_three`.

## Использование методов объектов

Объект в программировании — некоторая сущность в цифровом пространстве, обладающая определённым состоянием и поведением, имеющая определённые свойства (атрибуты) и операции над ними (методы).

Доступ к методам объектов в Python синтаксически происходит с помощью символа точки после имени объекта и указания имени метода или атрибута к которому нужно получить доступ.

```python
numbers = ['a', 'b']
numbers.append('c')
print(numbers)  # ['a', 'b', 'c']
```

В этом примере мы использовали метод `append`, который есть у списков и он есть у списка `numbers`. Этот метод добавляет новый элемент в конец списка.
В качестве аргумента этот метод получает элемент, который надо добавить в список. Аргументы указываются в скобках.

Если метод не требует аргументов (например метод `clear`), то скобки будут пустыми:

```python
num = [1, 2]
num.clear()
print(num)  # []
```

### Методы списков

* Добавление элемента в конец списка: ```my_list.append(element)```
    ```python
    chars = ['a', 'b']
    chars.append('c')
    print(chars)  # ['a', 'b', 'c']
    ```
* удаление элемента из списка, вызовет ошибку если такого элемента нет в списке: ```my_list.remove(element)```

    ```python
    chars = ['a', 'b']
    chars.remove('b')
    print(chars)  # ['a']
    ```
* Вернуть `i`-ый элемент и удалить его из списка ```i_element = my_list.pop(i)```. По-умолчанию ```i = -1```
  
    ```python
    chars = ['a', 'b']
    last = chars.pop(1)
    print(chars)  # ['a']
    print(last)  # 'b'
    ```
* Расширить список `a_list` элементами из `b_list`: ```a_list.extend(b_list)```
  
    ```python
    chars = ['a', 'b']
    numbers = [1, 2]

    chars.extend(numbers)
    print(chars)  # ['a', 'b', 1, 2]
    ```
* Вставить `x` на на позицию с индексом `i`: ```my_list.insert(i, x)```
  
    ```python
    chars = ['a', 'b']
    last = chars.pop(1)
    print(chars)  # ['a']
    print(last)  # 'b'
    ```
* Очистить список: ```my_list.clear()```
      ```python
    chars = ['a', 'b']
    last = chars.clear()
    print(chars)  # []
    ```
* Найти индекс первого элемента в списке равного `x`: ```index = my_list.index(x)```
      ```python
    chars = ['a', 'b', 'c', 'd']
    c_ind = chars.index('c')
    print(c_ind)  # 2
    ```
* Вернуть количество элементов в списке равных `x`: ```x_number = my_list.count(x)```
      ```python
    chars = ['a', 'b', 'c', 'a']
    a_count = chars.count('a')
    print(a_count)  # 2
    ```
* Отсортировать список по возрастанию: ```my_list.sort(key=None, reverse=False)```
      ```python
    chars = ['z', 'a', 'b']
    chars.sort()
    print(chars)  # ['a', 'b', 'z']
    ```
* Поменять порядок элементов в списке на обратный: ```my_list.reverse()```
      ```python
    chars = ['a', 'b']
    chars.reverse()
    print(chars)  # ['b', 'a']
    ```
* Вернуть копию списка: ```copy_of_my_list = my_list.copy()```
      ```python
    chars = ['a', 'b']
    chars_copy = chars.copy()
    chars == chars_copy # True
    ```

## Словари

Словарь &mdash; это контейнер который хранит пары ключ-значение.
Ключом может быть любой неизменяемый тип данных Python (число, строка, кортеж, пр.). 
Невозможно использовать в качестве ключа списки, словари, множества.
Значением словаря может быть любой тип данных Python включая пользовательские типы.

Пустой словарь можно создать одним из двух способов:
```python
empty_dict = {}
another_empty_dict = dict()
```

Создать непустой словарь можно следующим образом:
```python
some_dict = {
    "key": "value",
    1: "one",
}
```

Для создания заполненного некоторыми значениями словаря достаточно перечислить пары
ключ-значение через запятую внутри фигурных скобок, ключ идёт первым, потом двоеточие и значение.

В примере показано применение в качестве ключей строки и числа. 

Запись пары ключ-значение в уже существующий словарь происходит при помощи квадратных скобок и
оператора присвоения `=`:

```python
not_empty = {"key": "value"}
not_empty["new_key"] = "new value"
print(not_empty)    # {"key": "value", "new_key": "new value"}
``` 

### Методы словарей

Некоторые наиболее часто используемые методы словарей:

* ```pop(key)``` &mdash; возвращает значение элемента и удаляет пару ключ-значение из словаря
    ```python
    chars = {'a': 1, 'b': 2}
    b_num = chars.pop('b')
    print(chars)  # {'a': 1}
    print(b_num)  # 2
    ```
* ```update(another_dict)``` &mdash; расширяет словарь значениями из другого словаря
    ```python
    chars = {'a': 1, 'b': 2}
    chars.update({"c": 3})
    print(chars)  # {'a': 1, 'b': 2, "c": 3}
    ```
* ```clear()``` &mdash; очищает словарь не создавая нового
    ```python
    chars = {'a': 1, 'b': 2}
    chars.clear()
    print(chars)  # {}
    ```
* ```copy()``` &mdash; возвращает копию словаря
    ```python
    chars = {'a': 1, 'b': 2}
    chars_copy = chars.copy()
    chars_copy == chars  # True
    ```
* ```get(key[, default])``` &mdash; не вызывает исключения, если ключа нет в словаре, возвращает `default`, по умолчанию 
    `default=None`.
    ```python
    chars = {'a': 1, 'b': 2}
    c_idx = chars.get('c', -1)
    print(c_idx)  # -1
    ```

### Циклы и словари

Итерирование по словарю &mdash; это очень часто встречающийся блок кода и полезно уметь это делать.

Для начала следует сказать, что словарь сам по себе &mdash; это итерируемый контейнер и по нему можно итерироваться в
цикле `for` без необходимости заводить какой-то внешний счётчик и т.п. Создадим словарь в котором ключами будут числа,
а значениями &mdash; числительные на английском:
```python
numbers = {
    1: "one",
    2: "two",
    3: "three"
}
```

Теперь давайте просто пройдём по словарю в цикле и выведем что нам возвращает итератор на каждой итерации:
```python
for x in numbers:
    print(key)
```
В выводе вы увидите:
```
1
2
3
```
Итерируя по словарю вы перебираете ключи словаря. Точно такое же поведение можно получить используя метод `keys`,
но так вы явно укажете, что хотите перебрать ключи:
```python
for key in numbers.keys():
    print(key)
```
Ответ будет точно таким же:
```
1
2
3
```

Часто необходимо перебрать именно значения словаря, для этого воспользуемся методом `values`:
```python
for val in numbers.values():
    print(val)
```
В выводе будет:
```
one 
two
tree
```

И переберем пары ключ значение используя метод `items`. На каждой итерации мы получим пару (ключ, значение):
```python
for key, value in numbers.items():
    print(key, value)
```
Вывод:
```
1 one
2 two
3 three
```

Что __нельзя__ делать пока итерируетесь по словарю: нельзя удалять элементы из словаря, нельзя добавлять элементы в 
словарь. Но можно перезаписывать значения, если вы итерируетесь по ключам.
## Кортежи

Кортежи в Python &mdash; это упорядоченные неизменяемые множества элементов. Элементов кортежа как и списка может быть любой тип данных.
Главное отличие между кортежами и списками это то, что кортежи нельзя изменять, нельзя добавлять/удалять/переставлять элементы. 

Чтобы создать пустой список есть два способа, хотя и не совсем понятно зачем нужен пустой список :-)
```python
my_tuple = tuple()
another_tuple = ()
```

Создание же не пустых списков происходит следующим образом:
```python
not_empty = (1, 2, 3)
```

При попытке изменить кортеж вы получите сообщение об ошибке:
```python
not_empty[3] = 's'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-6-0e33ea041f91> in <module>()
----> 1 not_empty[3] = 's'

TypeError: 'tuple' object does not support item assignment
```

Неизменность кортежей ограничивает их применение по сравнению со списками, но даёт возможность использовать кортежи как ключи для словаря или элементы множества.
Например, рассмотрим набор точек на плоскости (кортежи). Их можно использовать как ключи в словаре:

```python
points = {
    (0, 0): "O"
    (1, 1): "A"
    (2, 2): "B"
}
```

В словаре `points` используются кортежи с координатами точек как ключи, а значения &mdash; это имена (названия) точек.


Есть одна важная особенность создания кортежей, это создание кортежей с одним элементом. Дело в том, что Python
использует круглые скобки как математические символы. Если написать выражение вида `a = (1)` возникает неопределенность.
Интерпретатор понимает такое выражение как сугубо математическое и просто убирает лишние скобки присваивая `a` значение 
`1`. Чтобы указать, что это не математическая операция, а именно кортеж, надо добавить запятую после значения. Тогда
интерпретатор однозначно поймёт что вы хотите создать кортеж с одним элементом: 
```python
a = (1, )
```

## Множества
Множество &mdash; это неупорядоченный контейнер, который содержит только уникальные элементы. В множество можно 
добавлять только неизменяемые типы данных.

Есть только один способ создать пустое множество:
```python
a = set()
print(a)    # set()
```

Для создания заполненного множества достаточно передать любой итерируемый объект в функцию `set`:
```python
a = set('hello')
print(a)    # {'e', 'h', 'l', 'o'}
```
Или же воспользоваться синтаксисом с фигурными скобками (как у словарей), но элементы в фигурных скобках просто
перечислить через запятую без двоеточий:
```python
b = {1, 2, 3, 4}
```

Уникальность подразумевает, что если множество уже содержит такой элемент, то попытка добавить ещё один такой же ничего не изменит.

```python
numbers = {1, 2, 3, 1, 2, 3}
print(numbers)    # {1, 2, 3}
```

### Методы множеств
Множества поддерживают следующие методы:

* ```add(elem)``` &mdash; добавляет элемент в множество
    ```python
    numbers = {1, 2, 3}
    numbers.add(4)
    print(numbers)    # {1, 2, 3, 4}
    ```
* ```remove(elem)``` &mdash; удаляет элемент из множества, вызывает исключение, если такого элемента нет
    ```python
    numbers = {1, 2, 3}
    numbers.remove(3)
    print(numbers)    # {1, 2}
    ```
* ```discard(elem)``` &mdash; удаляет элемент из множества и не вызывает исключения если его нету
    ```python
    numbers = {1, 2, 3}
    numbers.discard(2)
    print(numbers)    # {1, 3}
    ```

### Математические операции над множествами

Давайте детальнее рассмотрим какие полезные математические операции можно производить над множествами. 
Для начала создадим множества `a` и `b`: 
```python
a = set('hello')
print(a)    # {'e', 'h', 'l', 'o'}

b = set('hi there!')
print(b)    # {'r', ' ', 'i', 'e', '!', 'h', 't'}
```

Чтобы найти общие элементы для двух множеств выполним над ними операцию `&` (`AND`):
```python
a & b   # {'e', 'h'}
```

Найдем все элементы из двух множеств кроме общих при помощи оператора `^` (`XOR`):
```python
a ^ b   # {' ', '!', 'i', 'l', 'o', 'r', 't'}
```

Объединение множеств, или просто все элементы из обоих множеств находятся при помощи оператора  `|` (`OR`):
```python
a | b   # {' ', '!', 'e', 'h', 'i', 'l', 'o', 'r', 't'}
```

Множества &mdash; это очень мощный инструмент когда необходимо найти уникальные элементы в каком-то наборе и и убрать
дубликаты. Множество &mdash; это также самый быстрый способ найти общие или отличные элементы из нескольких наборов.

## Строки

Работа с текстовыми данными в Python реализована через str-объекты или строки.  
**Строка** - это неизменная упорядоченная последовательность символов в некоторой кодировке. 
По умолчанию используется кодировка UTF-8, но можно работать почти со всеми известными таблицами кодирования символов.
Для того, чтобы создать переменную типа "строка" необходимо определенный набор символов заключить в кавычки.

* Вариант 1. Одинарные кавычки (апостроф) `'some text'`
* Вариант 2. Двойные кавычки `"some text"`.

Различные варианты использования кавычек обусловлены тем, что при использовании одинарных кавычек, 
можно в строке указать двойные и наоборот.
```python
game_string = 'My "Game"'
```

**Упорядоченная** последовательность означает, что к элементам строки можно обращаться по индексу:
```python
s = "Hello world!"
print(s[0])   # H
print(s[-1])  # !
```

**Неизменная** последовательность означает, что если строка уже создана, то изменить её нельзя, можно только создать 
новую.

```python
s = "Hello world!"
s[0] = "Q" # Тут будет вызвано исключение (ошибка) TypeError
```

**Малые методы**

Для того чтобы все буквы строки перевести в верхний регистр используется метод `upper`:
```python
s = "Hello"
s.upper()
print(s)    # Выведет 'HELLO'
```

Для перевода в нижний регистр используется метод `lower()`:
```python
s = "Some Text"
print(s.lower())    # Выведет 'some text' 
```

Чтобы проверить что строка начинается с подстроки есть метод `startswith`:
```python
s = "Bill Jons"
print(s.startswith("Bi"))   # Выведет True
```

Чтобы проверить что строка заканчивается подстрокой используется метод `endswith`:
```python
s = "hello.jpg"
print(s.endswith("jpg"))    # Выведет True
```
Этот метод удобно использовать для проверки расширения файлов.

## Общие для всех коллекций операции

Такие разные списки, кортежи, словари, множества и строки объединяют в одну группу &mdash; коллекции потому, что у них есть общие свойства:

- проверка на вхождение;
- количество элементов;
- перебор всех элементов в цикле `for`.

### Проверка на вхождение

Любая коллекция позволяет проверить входит ли элемент в эту коллекции (есть ли там такой же). 
Для этого используется оператор `in`.

Например, проверка на то, что пользователь не использует простой пароль и в пароле не встречается последовательность `"qwerty"`
или `"123"`:

```python
password = "qwerty123"
if "qwerty" in password or "123" in password:
    print("This password is to weak!")
```

Оператор `in` проверяет наличие элемента (`'qwerty'`, `'123'`) в контейнере (`password`) и возвращает `True` или `False`.

```python
prime_numbers = {2, 3, 5, 7, 11, 13, 17, 19, 23}
is_prime = 3 in prime_numbers
```

Проверка на то, что число `3` есть в множестве первых девяти простых чисел `prime_numbers`.


Со словарями проверка на вхождение проверяет, что элемент есть среди ключей словаря.

```python
user = {
    "name": "Bill",
    "surname": "Bosh",
    "age": 22
}

if "age" in user:
    print(f"User is {user['age']} years old.")
```
### Количество элементов

Любая коллекция позволяет узнать количество элементов в ней при помощи функции `len`.

```python
password = input("Password: ")
if len(password) < 8:
    print("Your password is too short")
```

Например, проверка длинны пароля введенного пользователя может быть реализована с помощью функции `len`.

### Перебор всех элементов коллекции в цикле `for`

```python
alphabet = "abcdefghijklmnopqrstuvwxyz"
for char in alphabet:
    print(char)
```

По любой коллекции можно пройти с помощью цикла `for` и на каждой итерации в цикле будет получен один из элементов этой коллекции. 
В примере буквы алфавита из `alphabet` выводятся в консоль по очереди в цикле `for`.

Давайте проитерируем список `some_iterable` в цикле и выведем в консоль что мы получаем на каждой итерации:
```python
some_iterable = ["a", "b", "c"]

for i in some_iterable:
    print(i)
```
В консоли мы увидим:
```
a
b
c
```

```python
odd_numbers = [1, 3, 5, 7, 9]
for i in odd_numbers:
    print(i ** 2)
```

Код из этого примера выведет в консоль квадраты первых пяти нечетных чисел.

## Задачи

У многих на рабочем столе есть папка, которая называется как-то вроде "Разобрать". Как правило, разобрать эту папку руки
никогда так и не доходят. 

Мы с вами напишем скрипт, который разберет эту папку. В конечном итоге вы сможете настроить эту программу под себя и она
будет выполнять индивидуальный сценарий соответствующий вашим нуждам. 

На первом этапе мы рассортируем содержимое папки по категориям. Для этого приложение будет проверять расширение файла
(последние символы в имени файла, как правило после точки) и в зависимости от расширения принимать решение к какой 
категории отнести этот файл.

Пока не будем рассматривать вложенные папки (подпапки), но сделаем это когда выучим функции в Python.  

### Критерии приёмки:

На этом занятии мы напишем программу, которая рассортирует файлы в папке по категориям и выведет в консоль список 
файлов в каждой категории. 

Поскольку мы ещё не изучали работу с файловой системой и обработку аргументов запуска, вот код который берет первый 
аргумент (предположительно это адрес в файловой системе) и выводит в цикле все имена файлов и папок в этом каталоге.

```python
import os
import sys

# path содержит первый аргумент, считаем, что это валидный адрес в файловой системе
path = sys.argv[1]
print(f"Start in {path}")

# files - это список имен файлов и папок в path.
files = os.listdir(path)
```

Скрипт принимает один аргумент при запуске -- это имя папки в которой он будет проводить сортировку.
Допустим файл с программой называется `sort.py`, тогда чтобы отсортировать папку `/user/Desktop/Хлам` надо запустить
скрипт командой `python sort.py /user/Desktop/Хлам`

Категории и расширения которые должна поддерживать программа: 
* изображения ('JPEG', 'PNG', 'JPG');
* видео файлы ('AVI', 'MP4', 'MOV');
* документы ('DOC', 'DOCX', 'TXT');
* музыка ('MP3', 'OGG', 'WAV', 'AMR');
* неизвестные расширения, вложенные папки и пр.;

Вы можете расширить и дополнить этот список если хотите.

Скрипт выводит результаты работы в консоль. 

В результатах работы должны быть:
* Список файлов в каждой категории (музыка, видео, фото и пр.)
* Список всех расширений, которые встречаются в целевой папке.
 