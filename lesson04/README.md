# Функции

Функции – это многократно используемые фрагменты программы. Они позволяют дать имя определённому блоку команд с тем, чтобы впоследствии запускать этот блок по указанному имени в любом месте программы и сколь угодно много раз. Это называется вызовом функции.

## Создание и вызов функций

Функции определяются при помощи зарезервированного слова `def`. После этого слова указывается имя функции, за которым следует пара скобок, в которых можно указать имена некоторых переменных, и заключительное двоеточие в конце строки. Далее сле-дует блок команд, составляющих функцию. На примере можно видеть, что на самом деле это очень просто:

```python
def say_hello():
    print('Привет, Мир!')   # блок, принадлежащий функции
    # Конец функции say_hello()

# вызов функции 
say_hello()

# ещё один вызов функции
say_hello()
```

Мы определили функцию с именем `say_hello`, используя описанный выше синтаксис.
Эта функция не принимает параметров, поэтому в скобках не объ-явлены какие-либо переменные.
Параметры функции – это некие входные данные, которые мы можем передать функции, чтобы получить соответствующий им результат.

## Аргументы функции

Функции могут принимать параметры, т.е. некоторые значения, передаваемые функции для того, чтобы она что-либо сделала с ними.
Эти параметры похожи на переменные, за исключением того, что значение этих переменных указывается при вызове функции, и во время работы функции им уже присвоены их значения.
Параметры указываются в скобках при объявлении функции и разделяются запятыми.
Аналогично мы передаём значения, когда вызываем функцию. 
Обратите внимание на терминологию: имена, указанные в объявлении функции, называются параметрами, тогда как значения, которые вы передаёте в функцию при её вызове, – аргументами.

```python
def print_max(a, b):
    if a > b:
        print(a, 'максимально')
    elif a == b:
        print(a, 'равно', b)
    else:
        print(b, 'максимально')

print_max(3, 4)  # прямая передача значений 

x = 5
y = 7
print_max(x, y)  # передача переменных в качестве аргументов
```

Здесь мы определили функцию с именем `print_max`, которая использует два параметра с именами `a` и `b`.
Мы находим наибольшее число с применением простого оператора `if..else` и выводим это число.
При первом вызове функции `print_max` мы напрямую передаём числа в качестве аргументов. 
Во втором случае мы вызываем функцию с переменными в качестве аргументов `print_max(x, y)` назначает значение аргумента `x` параметру `a`, а значение аргумента `y` – параметру `b`.
В обоих случаях функция `print_max` работает одинаково.

## Возвращение результата

В Python нет синтаксической разницы между функциями и процедурами. 
По сути, функция имеет возвращать некоторый результат своей работы, а процедура ничего не возвращает и результатом ее работы может быть изменение состояния уже существующих переменных.
Такая форма использования функций максимально приближена к функциям, с которыми мы знакомы с уроков математики.

Для возвращения значения из функции необходимо указать что вернуть после ключевого слова `return`.
Например, функция, выполняющая операцию сложения.

```python
def plus(a, b):
  c = a + b
  return c

res = plus(3, 4)
print(res)  # Выведет 7 
```

Или ещё короче:

```python
def plus(a, b):
  return a + b

print(plus(3, 4))   # Выведет 7
```

## Локальные переменные

При объявлении переменных внутри определения функции, они никоим образом не связаны с другими переменными с таким же именем за пределами функции – т.е. имена переменных являются локальными в функции.
Это называется областью видимости переменной.
Область видимости всех переменных ограничена блоком, в котором они объявлены, начиная с точки объявления имени.

```python
x = 50

def func(x):
    print('x равен', x)     # x равен 50
    x = 2
    print('Замена локального x на', x)  # Замена локального x на 2

func(x)
print('x по-прежнему', x)   # x по-прежнему 50
```

При первом выводе значения, присвоенного имени `x`, в первой строке функции Python использует значение параметра, объявленного в основном блоке, выше определения функции.
Далее мы назначаем `x` значение `2`.
Имя `x` локально для нашей функции. 
Поэтому когда мы заменяем значение `x` в функции, `x`, объявленный в основном блоке, остаётся незатронутым.
Последним вызовом функции `print` мы выводим значение `x`, указанное в основном блоке, подтверждая таким образом, что оно не изменилось при локальном присваивании значения в ранее вызванной функции.

## Global

Чтобы присвоить некоторое значение переменной, определённой на высшем уровне программы (т.е. не в какой-либо области видимости, как то функции), необходимо указать Python, что её имя не локально, а глобально (`global`). 
Сделаем это при помощи зарезервированного слова `global`. Без применения зарезервированного слова `global` невозможно присвоить значение переменной, определённой за пределами функции.

```python
x = 50

def func():
    global x 
    print('x равно', x) # x равно 50
    x = 2
    print('Заменяем глобальное значение x на', x)   # Заменяем глобальное значение x на 2

func()
print('Значение x составляет', x)   # Значение x составляет 2
```

Зарезервированное слово `global` используется для того, чтобы объявить, что `x `– это глобальная переменная, а значит, когда мы присваиваем значение имени `x` внутри функции, это изменение отразится на значении переменной `x` в основном блоке программы.
Используя одно зарезервированное слово `global`, можно объявить сразу несколько переменных: `global x, y, z`.

## Значения аргументов по умолчанию

Зачастую часть параметров функций могут быть необязательными, и для них будут ис-пользоваться некоторые заданные значения по умолчанию, если пользователь не укажет собственных.
Этого можно достичь с помощью значений аргументов по умолчанию.
Их можно указать, добавив к имени параметра в определении функции оператор присваивания (`=`) с последующим значением.

```python
def say(message, times=1):
    print(message * times)

say('Привет')   # Привет
say('Мир', 5)   # МирМирМирМирМир
```

Функция под именем `say` используется для вывода на экран строки указанное число раз.
Если мы не указываем значения, по умолчанию строка выводится один раз.
Мы достигаем этого указанием значения аргумента по умолчанию, равного 1 для параметра `times`.
При первом вызове `say` мы указываем только строку, и функция выводит её один раз.
При втором вызове `say` мы указываем также и аргумент, обозначая таким образом, что мы хотим сказать фразу 5 раз.

Значениями по умолчанию могут быть снабжены только параметры, находящиеся в конце списка параметров.
Таким образом, в списке параметров функции параметр со значением по умолчанию не может предшествовать параметру без значения по умолчанию.
Это связано с тем, что значения присваиваются параметрам в соответствии с их положением. 
Например, `def func(a, b=5)` допустимо, а `def func(a=5, b)` – не допустимо.

## Ключевые аргументы

Если имеется некоторая функция с большим числом параметров, и при её вызове требуется указать только некоторые из них, значения этих параметров могут задаваться по их имени – это называется ключевые параметры.
В этом случае для передачи аргументов функции используется имя (ключ) вместо позиции (как было до сих пор).
Есть два преимущества такого подхода: во-первых, использование функции становится легче, поскольку нет необходимости отслеживать порядок аргументов; во-вторых, можно задавать значения только некоторым избранным аргументам, при условии, что остальные параметры имеют значения аргумента по умолчанию.

```python
def func(a, b=5, c=10):
    print('a равно', a,', b равно', b,', а c равно', c)
    
func(3, 7)          # a равно 3, b равно 7, а c равно 10
func(25, c=24)      # a равно 25, b равно 5, а c равно 24
func(c=50, a=100)   # a равно 100, b равно 5, а c равно 50
```

Функция с именем `func` имеет один параметр без значения по умолчанию, за которым следуют два параметра со значениями по умолчанию.
При первом вызове, `func(3, 7)`, параметр `a `получает значение `3`, параметр `b` получает значение `7`, а `c` получает своё значение по умолчанию, равное `10`.

При втором вызове `func(25, c=24)` переменная `a` получает значение `25` в силу позиции аргумента.
После этого параметр `c` получает значение `24` по имени, т.е. как ключевой параметр.
Переменная `b` получает значение по умолчанию, равное `5`.

При третьем обращении `func(c=50, a=100)` мы используем ключевые аргументы для всех указанных значений.
Обратите внимание на то, что мы указываем значение для параметра `c` перед значением для `a`, даже несмотря на то, что в определении функции параметр `a` указан раньше `c`.

## Переменное число параметров

Иногда бывает нужно определить функцию, способную принимать любое число параметров.
Этого можно достичь при помощи звёздочек:

```python
def total(a=5, *numbers, **phone_book):
    print('a', a)
    # проход по всем элементам кортежа 
    for single_item in numbers:
        print('single_item', single_item)
    
    #проход по всем элементам словаря
    for first_part, second_part in phone_book.items():
        print(first_part,second_part)
        
print(total(10, 1, 2, 3, Jack=1123, John=2231, Inge=1560))
```

В результате в консоли мы увидим:

```python
a 10
single_item 1
single_item 2
single_item 3
Inge 1560
John 2231
Jack 1123
None
```

Когда мы объявляем параметр со звёздочкой (например, `*param`), все позиционные аргументы начиная с этой позиции и до конца будут собраны в кортеж под именем `param`.
Аналогично, когда мы объявляем параметры с двумя звёздочками (`**param`), все ключевые аргументы начиная с этой позиции и до конца будут собраны в словарь под именем `param`.

## Рекурсия

Рекурсивная функция — это функция, определяемая в терминах самой себя и способная вызывать саму себя.
Это значит, что функция будет вызывать себя и повторять свое поведение до тех пор, пока не будет выполнено некоторое условие для возврата результата.

Наиболее частый пример использование рекурсивных функций — это вычисление факториала.
Для начала, напомним определение факториала из математики: факториал натурального числа `n` определяется как произведение всех натуральных чисел от 1 до `n` включительно.
Например: 5! = 1 &middot; 2 &middot; 3 &middot; 4 &middot; 5 = 120.
Это же определение можно записать рекурсивно:
5! = 5 &middot; 4!
4! = 4 &middot; 3!
3! = 3 &middot; 2!
2! = 2 &middot; 1!
1! = 1

```python
def factorial(n):
    if n <= 1:
        return 1
    else:
        return n * factorial(n - 1)

factorial(5)    # 120
```

Мы определили функцию `factorial`, которая принимает в качестве аргумента некоторое число `n`. Если `n` меньше или равно 1, то факториал такого числа уже известен и равен 1.
В противном случае, чтобы найти факториал числа `n` надо умножить `n` на факториал `n - 1`, а факториал `n - 1` мы находим использую функцию `factorial`.
Вызывать же `factorial` мы будем до тех пор, пока на очередной итерации `n` не станет меньше или равно 1.

Рекурсивные функции удобны в ситуациях, когда мы не знаем заранее сколько раз надо будет вызвать функцию, например при разборе попок на диске.
Приложение не знает заранее насколько глубока структура папок и какой у неё уровень вложенности.
И чтобы перебрать все файлы во всех вложенных папках функция должна вызывать сама себя когда встречает очередную папку.
Такая функция, которая вызывает сама себя при некоторых условиях называется рекурсивной.

## Импорт пакетов и модулей

У Python есть большой набор пакетов и модулей с готовыми полезными функциями и инструментами.
Если вам нужно сделать что-то, чего нет в стандартном небольшом наборе функций вы можете импортировать пакет где есть нужная функция чтобы использовать ёё.
Импортирование в Python происходит при помощи ключевого слова `import` после которого вы можете указать один или несколько пакетов которые вы хотите импортировать.

```python
import math

sin_pi = math.sin(math.pi)
```

В этом примере мы импортировали пакет математических функций и констант `math` и сохранили значение синуса &pi; в `sin_pi`

Для того, чтобы вызвать функцию из импортированного пакета нужно указать имя пакета и через точку имя функции или константы в этом пакете.
Этот синтаксис очень похож на вызов метода, мы делали так со словарями и списками ранее.

Есть и другой способ, можно импортировать из пакета только то, что нам нужно с помощью выражения `from ... import ...`:

```python
from math import pi, sin

sin_pi = sin(pi)
```

Этот код делает тоже, что и код выше. Используйте тот синтаксис, который вам кажется удобнее.

## Работа с файловой системой, пакет pathlib

Для работы с файловой системой в стандартной поставке Python идет пакет `pathlib`, он содержит множество полезных функций для работы с файловой системой.
Детальный перечень возможностей `pathlib` рекомендуем изучить на [странице официальной документации](https://docs.python.org/3/library/pathlib.html).

Основной инструмент в `pathlib` &mdash; `Path`, объект, который представляет собой путь (адрес в файловой системе).
В основном работа с файловой системой ведётся через `Path`.
`Path` следует воспринимать как указатель на файл или папку.
Чтобы создать такой `Path` достаточно вызвать `Path` как функцию и передать в качестве аргумента строку-адрес в файловой системе:

```python
from pathlib import Path

p = Path('/home/user/Downloads')    # p Указывает на папку /home/user/Downloads
```

Можно вызвать `Path` без аргументов, тогда вы получите указатель на папку в которой вы сейчас находитесь.

```python
from pathlib import Path

p = Path()  # p Указывает на папку из которой был запущен Python
```


У `Path` есть ряд полезных методов и атрибутов:

- `p.parent` указывает на родительскую папку;
- `p.name` возвращает только имя (строкой) папки или файла на который указывает `p`;
- `p.suffix` возвращает строкой расширение файла на который указывает `p` начиная с точки;
    ```python
    p = Path('setup.py')
    p.suffix    # '.py'
    ```
- `p.exists()` возвращает `True` или `False` в зависимости от того, существует ли такой файл или папка;
- `p.is_dir()` возвращает `True` если `p` указывает на папку и `False`, если на файл, или такой путь не существует;
- `p.is_file()` возвращает `True` если `p` указывает на файл и `False`, если на папку, или такой путь не существует;
- `p.iterdir()` возвращает итератор по всем файлам и папкам внутри папки `p`;
    ```python
    from pathlib import Path

    p = Path('/home/user/Downloads')    # p Указывает на папку /home/user/Downloads
    for i in p.iterdir():
        print(i.name)   # Выведет в цикле имена всех папок и файлов в /home/user/Downloads
    ```
    Следует понимать, что `i` в этом примере также будут объектами `Path`, но указывать они будут на файлы и папки внутри `'/home/user/Downloads'`.
    
    С концепцией объектов мы познакомимся несколько позднее, пока достаточно знать, что у `i` &mdash; это как и `p` тоже указатели на папки и файлы, но каждый `i` указывает на какой-то свой файл или папку.

## Обработка аргументов командной строки

Когда запускаем сохраненный в файле Python скрипт есть возможность передать ему при запуске какие-то аргументы, как в функцию.
Тогда наш скрипт может эти аргументы принять и как-то изменить своё поведение.
Сделать это можно при помощи пакета `sys` в котором есть список `argv` где появляются все аргументы с которыми был запущен скрипт.

Интересной особенностью `sys.argv` есть то, что первым элементом этого списка будет название самого файла скрипта.
Все аргументы будут в `sys.argv` в виде строк в том же порядке, в котором они были переданы при вызове.
Python разделяет аргументы пробелами и в `sys.argv` пробелы не попадают.

Чтобы понять как работает `sys.argv` можете сделать простой скрипт `echo.py`, который будет выводить в консоль все переданные при вызове аргументы.

```python
import sys

for arg in sys.argv:
    print(arg)
```

Если вызвать скрипт с таким содержимым (допустим он называется `echo.py`) командой: `python echo.py test --user -hello some text`, то в консоли вы увидите:

```python
echo.py
test
--user
-hello
some
text
```

## Задача

На этом занятии мы продолжим разбирать папку с файлами. 
В прошлый раз мы договорились, что вложенные папки не будем рассматривать. 
Сейчас вы уже знаете как создавать и использовать функции в Python и как создавать рекурсивные функции. 
Этот навык поможет сделать наш скрипт более универсальным и он сможет обрабатывать вложенные папки, более сложную, вложенную структуру файловой системы.

## Критерии приёма задания

* Для того, чтобы успешно справится с этим заданием вы должны вынести логику обработки папки в отдельную функцию.
* Чтобы скрипт мог пройти на любую глубину вложенности функция обработки папок должна рекурсивно вызывать сама себя когда ей встречаются вложенные папки.

Скрипт должен проходить по указанной во время вызова папке и сортировать все файлы по группам:
* изображения ('JPEG', 'PNG', 'JPG', 'SVG');
* видео файлы ('AVI', 'MP4', 'MOV', 'MKV');
* документы ('DOC', 'DOCX', 'TXT', 'PDF', 'XLSX', 'PPTX');
* музыка ('MP3', 'OGG', 'WAV', 'AMR');
* архивы ('ZIP', 'GZ', 'TAR');
* неизвестные расширения.

Вы можете расширить и дополнить этот список если хотите.

Скрипт выводит результаты работы в консоль. 

В результатах работы должны быть:
* Список файлов в каждой категории (музыка, видео, фото и пр.)
* Перечень всех известных скрипту расширений, которые встречаются в целевой папке.
* Перечень всех расширений, которые скрипту неизвестны.
