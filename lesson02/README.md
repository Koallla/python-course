# Модуль 2. Циклы. Исключения

```python
name = input("What is your name? ")
print(f"Hello {name}")
```

По-умолчанию в Python инструкции выполняются одна за одной сверху вниз.
В примере две инструкции, сначала выполнится `name = input("What is your name? ")`, потом `print(f"Hello {name}")`.

Последовательность выполнения выражений в программе называется «поток выполнения» (Flow of execution).

Программы, в которых все команды выполняются одна за одной называются *линейными программами*, пример выше &mdash; это линейная программа,
инструкции выполнятся все и строго по очереди.

В Python существует три способа управления потоком выполнения:

* условное выполнение &mdash; выполнения блока инструкций только при наступлении некоторого условия;
* циклы &mdash; повторение выполнения блока инструкций пока выполняется некоторое условие;
* исключения &mdash; выполнение блока инструкций в случае ошибки.

Мы уже рассмотрели условное выполнение, в этом модуле рассмотрим циклы и исключения.

## Булева алгебра

Простые логические выражения представляют собой конструкции описывающее одно условие, например:

```python
age = int(input("How old are you?"))
adult = age >= 18
```

Но что делать, когда у нас сложное условие, которое сочетает в себе несколько вложенных условий? Например, чтобы пользователь мог арендовать автомобиль надо чтобы у пользователя обязательно было указанно имя, пользователь был старше 18 и имелись водительские права.

```python
name = "Taras"
age = 22
has_driver_licence = True

if name and age >= 18 and has_driver_licence:
    print(f"User {name} can rent a car")
```

Для построения логических условий из нескольких используется булева алгебра.

__Булева алгебра &mdash; это раздел математической логики, в котором изучаются логические операции над высказываниями.__

В программировании применяют бинарную логику, возможные значения для бинарной логики могут быть `True` и `False`.

Булева алгебра строится на трёх основных операциях: "И", "ИЛИ", "НЕ". Есть ещё вспомогательные, но давайте пока рассмотрим основные.

В Python операторы булевой алгебры &mdash; это операторы `not`, `and`, `or`.

### and (И) выражение выполняется, если оба условия выполняются

<table class="tg">
<thead>
  <tr>
    <th class="tg-c3ow">A</th>
    <th class="tg-c3ow">B</th>
    <th class="tg-c3ow">A and B</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
  </tr>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">False</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
  </tr>
</tbody>
</table>

```python
a = True and False  # False
```

### or (ИЛИ) выражение выполняется, если хоть одно из условий выполняется

<table class="tg">
<thead>
  <tr>
    <th class="tg-c3ow">A</th>
    <th class="tg-c3ow">B</th>
    <th class="tg-c3ow">A or B</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
  </tr>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">True</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
  </tr>
</tbody>
</table>

```python
a = True or False  # True
```

#### not (НЕ) отрицание, выражение выполняется, если операнд - ложь

<table class="tg">
<thead>
  <tr>
    <th class="tg-c3ow">A</th>
    <th class="tg-c3ow">not A</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">False</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">True</td>
  </tr>
</tbody>
</table>

```python
a = not 2 < 0  # True
```

## Циклы

Для того, чтобы повторить какой-то блок кода несколько раз или повторять пока выполняется некоторое условие в Python,
реализованны циклы. Есть два вида циклов:

* цикл `for`, который ещё называют итерирующим, он перебирает все элементы некоторой последовательности;
* цикл `while`, который выполняется пока выполняется некоторое условие.

__Итерация (лат. iteratio «повторение») &mdash; повторение какого-либо действия.__
Итерация в программировании &mdash; организация обработки данных, при которой действия повторяются многократно, не приводя при этом к вызовам самих себя.

Одна итерация &mdash; это одно повторение.

### Цикл for

В Python, цикл `for` используется для перебора всех элементов контейнеров, или итерируемых объектов, например, списков.
Инструкции, которые находятся в теле цикла будут выполнены столько раз, сколько элементов в списке.

При этом, на каждой итерации специальная переменная получает значение одного из элементов списка.

Работу цикла `for` можно сравнить с тем, что вы по очереди возьмете каждую букву из фразы и проговорите её.
Фразой будет выступать строка `'apple'`, а аналогом произнесения вслух будет выступать вывод соответствующей буквы в консоль.

```python
fruit = 'apple'
for char in fruit:
    print(char)
```

Синтаксис цикла `for`:

1. цикл начинается с ключевого слова `for`;
2. за которым обязательно идёт название переменной куда будет записываться значение получаемое из итерируемого объекта на каждой итерации;
3. далее следует ключевое слово `in`;
4. за которым обязательно идёт выражение или объект по которому собственно будет итерироваться `for`;
5. далее ставится `:`;
6. и с новой строки с отступом идёт набор выражений, которые будут повторятся на каждой итерации

### Цикл while

Цикл `while` позволяет выполнять инструкции, которые находятся в теле цикла до тех пор, пока выполняется условие, указанное в цикле.
Например, цикл `while`, который выводит числа от 1 до 5:

```python
a = 1
while a <= 5:
    print(a)
    a = a + 1
```

### «Бесконечные циклы» и `break`

Бывают ситуации, когда необходимо выйти из цикла до завершения итерации, не дожидаясь пока произойдет очередная проверка условия.
Для этого есть команда `break`. Команда `break` останавливает цикл в момент вызова и не завершает итерацию.

```python
a = 0
while True:
    print(a)
    if a == 20:
        break
    a = a + 1
```

В этом примере условие цикла будет выполнятся всегда, ведь `True` всегда будет `True`. Это пример бесконечного цикла. Но из-за проверки что `a == 20` этот цикл завершится как только в `a` будет значение `20`.

Бесконечные циклы часто применяются там где надо взаимодействовать с клиентом ожидая ввода от него и завершаться только при наступлении некоторого условия.

Например echo скрипт, который выводит в консоль то, что вы введете, пока вы не введете `exit`:

```python
while True:
    user_input = input()
    print(user_input)
    if user_input == "exit":
        break
```

### Завершение итерации с помощью continue

Также для того, чтобы сразу перейти к следующей итерации цикла без выполнения оставшихся выражений есть команда `continue`.
Вызов этой команды в теле цикла приводит к тому, что оставшиеся выражения этой итерации не будут выполнены,
а интерпретатор сразу перейдет к следующей итерации или проверке условия.

```python
a = 0
while a < 20:
    a = a + 1
    if a % 2 == 0:
        continue
    print(a)
```

Операторы `continue` и `break` работают только внутри одного цикла. В ситуации вложенных циклов нет способа выйти из всех циклов сразу.
Также использование `continue` или `break` вне цикла приводит к синтаксической ошибке.

В этом примере использовался оператор получения остатка от деления `%`, он возвращает такое число `p`,
что если его отнять от `r`, то выполнится условие `r / x == 0`.

## Исключения

Преобразовать в `int` или `float` можно не любую строку. Например, если пользователь введет `'a'`, то интерпретатор не сможет определить как преобразовать символ `a` в целое число и вызовет исключение `ValueError`.

```python
int("a")
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-6-d9136db7b558> in <module>
----> 1 int("a")

ValueError: invalid literal for int() with base 10: 'a'
```

Исключение в Python &mdash; это ошибка на уровне интерпретатора, вызванная невозможностью выполнить тот или иной оператор
по каким-либо причинам (переменная не существует, синтаксическая ошибка, отсутствует атрибут, операция деления на ноль и т.п.).

В данном случае программа прекратит свою работу и пользователь так и не узнает, что привело к этому сбою.

В нашем примере (ввели `'а'`) интерпретатор пытается преобразовать строку в тип `int` (целое число), но как переводится строка `'a'` в число &mdash; не определено и будет вызвано исключение по этому поводу.

### Механизм обработки исключений

Для обработки исключений существует оператор `try ... except ...`. Синтаксически, этот оператор начинается с ключевого слова `try:` (попробовать) и продолжается блоком кода на следующей строке, который выделен отступом.

Далее идет блок обработки исключений `except` (кроме), где можно указать одно, или более исключений, после которых выполнить следующий блок кода.
Этот блок не обязателен, но чаще всего нужен. Он выполнится если случится указанное исключение (одно из них, если их несколько).

Потом идёт необязательный блок кода, который начинается с ключевого слова `finally`, он выполнится в любом случае.

Последним идёт необязательный блок, который начинается с ключевого слова `else`. Этот код выполнится только если исключений не случилось.

В нашем примере обработка пользовательского ввода будет выглядеть следующим образом:

```python
val = 'a'
try:
    val = int(val)
except ValueError:
    print(f"val {val} is not a number")
else:
    print("Its ok")
finally:
    print("This will be printed anyway")
```

Исключения в Python &mdash; это очень мощный инструмент, который часто используется для управления потоком выполнения, а не
только для обработки ошибок. В динамических языках никогда нельзя быть на 100% уверенным в том, что пользователь
ввёл значение корректного типа или что другое приложение не вернуло `None` вместо `int`, например.

Наивным решением этой проблемы будет повсеместное использование проверок `if` на корректность введенного пользователем
или другим приложением значения. Более продвинутым, удобным и прозрачным решением является использование механизма
обработки исключений там, где они могут случиться из-за некорректных входных данных.  

```python
age = input("How old are you? ")
try:
    age = int(age)
    if age >= 18:
        print("You are adult.")
    else:
        print("You are infant")
except ValueError:
    print(f"{age} is not a number")
```

### Основные типы исключений в Python

`SyntaxError` синтаксическая ошибка.

`IndentationError` ошибка которая возникает если в выделении блоков инструкций пробелами допущена ошибка.

`TabError` возникает если в одном файле использовать пробелы и табуляции для выделения блоков инструкций.

`TypeError` возникает когда операция с переменной этого типа невозможна.

```python
2 / 'a'
```

`ValueError` возникает когда тип операнда подходящий, но значение таково, что операцию невозможно выполнить.

```python
int("a")
```

`ZeroDivisionError` деление на ноль.

## Домашнее задание

Напишите программу, которая будет выполнять простейшие математические операции с числами последовательно принимая
от пользователя операнды (числа) и оператор.

### Условия приёмки

* Приложение работает с целыми и дробными числами.
* Приложение умеет выполнять такие математические операции:
  * СЛОЖЕНИЕ (+)
  * ВЫЧИТАНИЕ (-)
  * УМНОЖЕНИЕ (*)
  * ДЕЛЕНИЕ (/)
* Приложение принимает один операнд или один оператор за один цикл запрос-ответ.
* Все операции приложение выполняет по мере поступления одну за одной.
* Приложение выводит результат вычислений когда получает от пользователя `=`.
* Приложение заканчивает свою работу после того, как выведет результат вычисления.
* Пользователь по очереди вводит числа и операторы.
* Если пользователь вводит оператор два раза подряд, то он получает сообщение об ошибке и может ввести повторно.
* Если пользователь вводит число два раза подряд, то он получает сообщение об ошибке и может ввести повторно.
* Приложение корректно обрабатывает ситуацию некорректного ввода.
