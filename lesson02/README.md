# Модуль 2. Управляющие конструкции. Исключения

```python
name = input("What is your name? ")
print(f"Hello {name}")
```

По-умолчанию в Python инструкции выполняются одна за одной сверху вниз.
В примере две инструкции, сначала выполнится `name = input("What is your name? ")`, потом `print(f"Hello {name}")`.

Последовательность выполнения выражений в программе называется «поток выполнения» (Flow of execution).

В Python существует три способа управления потоком выполнения:

* условное выполнение &mdash; выполнения блока инструкций только при наступлении некоторого условия;
* циклы &mdash; повторение выполнения блока инструкций пока выполняется некоторое условие;
* исключения &mdash; выполнение блока инструкций в случае ошибки.

## Условное выполнение

```python
age = input("How old are you? ")

if int(age) >= 18:
    print("You are adult already.")
else:
    print("You are infant yet.")
```

В Python реализован оператор контроля выполнения (условный оператор) `if ... elif ... else`.

Оператор контроля исполнения позволяет выполнять блоки инструкций не всегда, а только тогда, когда будет выполнено условие.

Синтаксис условного оператора:

* начинается с ключевого слова `if` за которым следует условие;

* после условия ставится двоеточие и с новой строки с отступом идет блок инструкций, которые будут выполнены в если условие выполняется;

* после блока `if` может быть ноль или более блоков `elif`, интерпретатор последовательно будет проверять все условия `elif` сверху вниз, пока не найдет то, которое выполняется;

* после может быть один блок `else`, который выполнится, если все предыдущие условия не выполняются.

```python
a = input('Введите число')
a = int(a)
if a > 0:
    print('Число положительное')
elif a < 0:
    print("Число отрицательное")
else:
    print('Это число - ноль')
```

Во время выполнения условного оператора интерпретатор Python проверяет условия сверху вниз пока не найдет то,
которое выполняется, затем выполнит выражение для этого условия и выйдет из проверки условий.

```python
a = input('Введите число')
a = int(a)
if a > 0:
    print('Число положительное')
elif a == 1:
    print('Число равно 1')
else:
    print("a <= 0")
```

В таком случае код для условия `a == 1` никогда не выполнится.

## Условия в Python

Условный оператор `if ... elif ... else` в Python в качестве условий может принимать переменные типа `bool` или любое выражение, которое он выполнит и результат преобразует в `bool`.

### Логические выражения

Когда в качестве условия в условный оператор мы передаем выражение, то выражение выполнится, а результат его выполнения будет преобразован в тип `bool`.

Для удобства в Python есть механизм неявного приведения любого типа к типу `bool`.
Правила приведения к `bool` &mdash; интуитивны:

* число `0` приводится к `False` (целое, дробное или комплексное);
  
    ```python
    money = 0
    if money:
        print(f"You have {money} on your bank account")
    else:
        print("You have no money and no debts")
    ```

* `None` приводится к `False`;

    ```python
    result = None
    if result:
        print(result)
    else:
        print("Result is None, do something")
    ```

* пустой контейнер (пустая строка и т.п.) приводятся к `False`

    ```python
    user_name = input("Enter your name: ")

    if user_name:
        print(f"Hello {user_name}")
    else:
        print("Hi Anonym!")
    ```

* всё остальное приводится к `True`

Правила приведения к `bool` позволяют писать условные выражения в Python практически на литературном английском. В любом случае, такой код становится очень понятным.

### Булева алгебра

Что делать, когда у нас сложное условие, которое сочетает в себе несколько вложенных условий? Например, чтобы пользователь мог арендовать автомобиль надо чтобы у пользователя обязательно было указанно имя, пользователь был старше 18 и имелись водительские права.

```python
name = "Taras"
age = 22
has_driver_licence = True

if name and age >= 18 and has_driver_licence:
    print(f"User {name} can rent a car")
```

Для построения логических условий из нескольких используется булева алгебра.

__Булева алгебра &mdash; это раздел математической логики, в котором изучаются логические операции над высказываниями.__

В программировании применяют бинарную логику, возможные значения для бинарной логики могут быть `True` и `False`.

Булева алгебра строится на трёх основных операциях: "И", "ИЛИ", "НЕ". Есть ещё вспомогательные, но давайте пока рассмотрим основные.

В Python операторы булевой алгебры &mdash; это операторы `not`, `and`, `or`.

### and (И) выражение выполняется, если оба условия выполняются

<table class="tg">
<thead>
  <tr>
    <th class="tg-c3ow">A</th>
    <th class="tg-c3ow">B</th>
    <th class="tg-c3ow">A and B</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
  </tr>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">False</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
  </tr>
</tbody>
</table>

```python
a = True and False  # False
```

### or (ИЛИ) выражение выполняется, если хоть одно из условий выполняется

<table class="tg">
<thead>
  <tr>
    <th class="tg-c3ow">A</th>
    <th class="tg-c3ow">B</th>
    <th class="tg-c3ow">A or B</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
  </tr>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">True</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
  </tr>
</tbody>
</table>

```python
a = True or False  # True
```

#### not (НЕ) отрицание, выражение выполняется, если операнд - ложь

<table class="tg">
<thead>
  <tr>
    <th class="tg-c3ow">A</th>
    <th class="tg-c3ow">not A</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">False</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">True</td>
  </tr>
</tbody>
</table>

```python
a = not 2 < 0  # True
```

## Тернарные операции

Тернарные операторы &mdash; это те же условные выражения, но в сокращенной форме.
Эти операторы возвращают что-то в зависимости от того, является ли условие истиной или ложью.

```python
is_nice = True
state = "nice" if is_nice else "not nice"
```

В этом примере в `state` будет строка `'nice'`.

Такой подход позволяет быстро проверить условие, а не писать несколько строчек оператора `if ... else ...`.

В Python также существует более краткий вариант тернарного оператора.

```python
some_data = None
msg = som_data or "Нет данных"
```

В этом примере `msg` содержит строку `'Не было возвращено данных'` это удобно,
когда нужно быстро проверить значение и показать сообщение, если значения `None`.

**Обратите внимание** что для сокращенной формы используется именно оператор `or` (**ИЛИ**).

## Блоки инструкций

```python
x = input("X: ")
y = input("Y: ")

if x == 0:
    print("X can`t be equal to zero")
    x = input("X: ")

result = y / x
```

У Python особый синтаксис касательно выделения блоков инструкций. Чтобы интерпретатор воспринял набор инструкций как отдельный
блок достаточно выделить все инструкции этого блока одинаковым количеством отступов слева.
В Python рекомендуется для выделения одного уровня вложенности для блока инструкций использовать **4 пробела**.

Вы можете использовать символы табуляции для выделения блока инструкций, это не ошибка, но такой способ не рекомендуется.

Синтаксической **ошибкой** будет смешать в одном файле выделение блоков  при помощи **табуляций и пробелов одновременно**.

Вы также можете выделять несколько уровней вложенности добавляя ещё 4 пробела слева для всех инструкций блока:

```python
x = input("X: ")
y = input("Y: ")

if x == 0:
    print("X can`t be equal to zero")
    x = input("X: ")

    if x == 0:
        print("X can`t be equal to zero")
        x = input("X: ")

        if x == 0:
            print("X can`t be equal to zero")
            x = input("X: ")

result = y / x
```

В этом примере трижды повторяется проверка на неравенство `x` нулю и на каждую проверку блок инструкций выделяется дополнительными 4-мя пробелами.

Пример вложенности для определения четвертей для координатной плоскости.

```python
if x >= 0:
    if y >= 0:               # x > 0, y > 0
        print("Первая четверть")
    else:                    # x > 0, y < 0
        print("Четвертая четверть")
else:
    if y >= 0:               # x < 0, y > 0
        print("Вторая четверть")
    else:                    # x < 0, y < 0
        print("Третья четверть")
```

## Циклы

Для того, чтобы повторить какой-то блок кода несколько раз или повторять пока выполняется некоторое условие в Python,
реализованны циклы. Есть два вида циклов:

* цикл `for`, который ещё называют итерирующим, он перебирает все элементы некоторой последовательности;
* цикл `while`, который выполняется пока выполняется некоторое условие.

__Итерация (лат. iteratio «повторение») &mdash; повторение какого-либо действия.__
Итерация в программировании &mdash; организация обработки данных, при которой действия повторяются многократно, не приводя при этом к вызовам самих себя.

Одна итерация &mdash; это одно повторение.

### Цикл for

В Python, цикл `for` используется для перебора всех элементов контейнеров, или итерируемых объектов, например, списков.
Инструкции, которые находятся в теле цикла будут выполнены столько раз, сколько элементов в списке.

При этом, на каждой итерации специальная переменная получает значение одного из элементов списка.

Работу цикла `for` можно сравнить с тем, что вы по очереди возьмете каждую букву из фразы и проговорите её.
Фразой будет выступать строка `'apple'`, а аналогом произнесения вслух будет выступать вывод соответствующей буквы в консоль.

```python
fruit = 'apple'
for char in fruit:
    print(char)
```

В результате выполнения этого кода вы увидите в консоли:

```python
a
p
p
l
e
```

Синтаксис цикла `for`:

1. цикл начинается с ключевого слова `for`;
2. за которым обязательно идёт название переменной куда будет записываться значение получаемое из итерируемого объекта на каждой итерации;
3. далее следует ключевое слово `in`;
4. за которым обязательно идёт выражение или объект по которому собственно будет итерироваться `for`;
5. далее ставится `:`;
6. и с новой строки с отступом идёт набор выражений, которые будут повторятся на каждой итерации

### Цикл while

Цикл `while` позволяет выполнять инструкции, которые находятся в теле цикла до тех пор, пока выполняется условие, указанное в цикле.
Например, цикл `while`, который выводит числа от 1 до 5:

```python
a = 1
while a <= 5:
    print(a)
    a = a + 1
```

### «Бесконечные циклы» и `break`

Бывают ситуации, когда необходимо выйти из цикла до завершения итерации, не дожидаясь пока произойдет очередная проверка условия.
Для этого есть команда `break`. Команда `break` останавливает цикл в момент вызова и не завершает итерацию.

```python
a = 0
while True:
    print(a)
    if a >= 20:
        break
    a = a + 1
```

В этом примере условие цикла будет выполнятся всегда, ведь `True` всегда будет `True`. Это пример бесконечного цикла. Но из-за проверки что `a >= 20` этот цикл завершится как только в `a` будет значение `20` или больше.

Бесконечные циклы часто применяются там где надо взаимодействовать с клиентом ожидая ввода от него и завершаться только при наступлении некоторого условия.

Например echo скрипт, который выводит в консоль то, что вы введете, пока вы не введете `exit`:

```python
while True:
    user_input = input()
    print(user_input)
    if user_input == "exit":
        break
```

### Завершение итерации с помощью continue

Также для того, чтобы сразу перейти к следующей итерации цикла без выполнения оставшихся выражений есть команда `continue`.
Вызов этой команды в теле цикла приводит к тому, что оставшиеся выражения этой итерации не будут выполнены,
а интерпретатор сразу перейдет к следующей итерации или проверке условия.

```python
a = 0
while a < 6:
    a = a + 1
    if not a % 2:
        continue
    print(a)
```

В консоли вы увидите:

```python
1
3
5
```

Инструкция `print(a)` не выполнялась когда `a` делилось на 2 без остатка поскольку итерация завершалась при помощи `continue`.

В этом примере использовался оператор получения остатка от деления `%`, он возвращает такое число `p`, что если его отнять от `r`, то результат будет делиться на `x` нацело:

`(r - p) / x = a`,

где `а`, `x`, `r` &mdash; целые числа.

Операторы `continue` и `break` работают только внутри одного цикла. В ситуации вложенных циклов нет способа выйти из всех циклов сразу.

````python
while True:
    number = input("number = ")
    number = int(number)
    while True:
        print(number)
        number = number - 1
        if number < 0:
            break
````

В этом примере пользователь вводит число и получает обратный отсчет от этого числа до 0 в консоли.
При этом, внешний бесконечный цикл никак не прервать и `break` выйдет только из внутреннего цикла.

Также использование `continue` или `break` вне цикла приводит к синтаксической ошибке.

```python
number = input("number = ")
if number < 0:
    break
```

Такой код вызовет ошибку `SyntaxError`. Такие ошибки называются исключениями.

## Исключения

Преобразовать в `int` или `float` можно не любую строку. Например, если пользователь введет `'a'`, то интерпретатор не сможет определить как преобразовать символ `a` в целое число и вызовет исключение `ValueError`.

```python
int("a")
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-6-d9136db7b558> in <module>
----> 1 int("a")

ValueError: invalid literal for int() with base 10: 'a'
```

Исключение в Python &mdash; это ошибка на уровне интерпретатора, вызванная невозможностью выполнить тот или иной оператор по каким-либо причинам (переменная не существует, синтаксическая ошибка, отсутствует атрибут, операция деления на ноль и т.п.).

В нашем примере (ввели `'а'`) интерпретатор пытается преобразовать строку в тип `int` (целое число), но как преобразовать строку `'a'` в число не определено и будет вызвано исключение по этому поводу.

### Механизм обработки исключений

Для обработки исключений существует оператор `try ... except ...`. Синтаксически, этот оператор начинается с ключевого слова `try:` (попробовать) и продолжается блоком кода в котором мы ожидаем что может случится ошибка.

Далее идет блок обработки исключений `except` (кроме), где можно указать одно, или более исключений. Если одно из указанных исключений случится, то выполнится следующий блок кода.

Этот блок не обязателен, но чаще всего нужен. Он выполнится если случится указанное исключение (одно из них, если их несколько).

Если ошибки могут быть разные и обрабатывать их нужно тоже оп разному, то можно добавить несколько
блоков `except` в каждом указать свою ошибку и что делать если она случится.

Потом идёт необязательный блок, который начинается с ключевого слова `else`. Этот код выполнится только если исключений не случилось.

Последним идёт необязательный блок кода, который начинается с ключевого слова `finally`, он выполнится в любом случае, вне зависимости от того были ошибки или нет.

В нашем примере обработка пользовательского ввода будет выглядеть следующим образом:

```python
val = 'a'
try:
    val = int(val)
except ValueError:
    print(f"val {val} is not a number")
else:
    print(val > 0)
finally:
    print("This will be printed anyway")
```

Исключения в Python &mdash; это очень мощный инструмент, который часто используется для управления потоком выполнения, а не только для обработки ошибок. В динамических языках никогда нельзя быть на 100% уверенным в том, что пользователь ввёл значение корректного типа или что другое приложение не вернуло `None` вместо `int`, например.

Наивным решением этой проблемы будет повсеместное использование проверок `if` на корректность введенного пользователем или другим приложением значения. Более продвинутым, удобным и прозрачным решением является использование механизма обработки исключений там, где они могут случиться из-за некорректных входных данных.  

```python
age = input("How old are you? ")
try:
    age = int(age)
    if age >= 18:
        print("You are adult.")
    else:
        print("You are infant")
except ValueError:
    print(f"{age} is not a number")
```

### Основные типы исключений в Python

`SyntaxError` синтаксическая ошибка.

`IndentationError` ошибка которая возникает если в выделении блоков инструкций пробелами допущена ошибка.

`TabError` возникает если в одном файле использовать пробелы и табуляции для выделения блоков инструкций.

`TypeError` возникает когда операция с переменной этого типа невозможна.

```python
2 / 'a'
```

`ValueError` возникает когда тип операнда подходящий, но значение таково, что операцию невозможно выполнить.

```python
int("a")
```

`ZeroDivisionError` деление на ноль.

## Домашнее задание

Напишите программу, которая будет выполнять простейшие математические операции с числами последовательно принимая
от пользователя операнды (числа) и оператор.

### Условия приёмки

* Приложение работает с целыми и дробными числами.
* Приложение умеет выполнять такие математические операции:
  * СЛОЖЕНИЕ (+)
  * ВЫЧИТАНИЕ (-)
  * УМНОЖЕНИЕ (*)
  * ДЕЛЕНИЕ (/)
* Приложение принимает один операнд или один оператор за один цикл запрос-ответ.
* Все операции приложение выполняет по мере поступления одну за одной.
* Приложение выводит результат вычислений когда получает от пользователя `=`.
* Приложение заканчивает свою работу после того, как выведет результат вычисления.
* Пользователь по очереди вводит числа и операторы.
* Если пользователь вводит оператор два раза подряд, то он получает сообщение об ошибке и может ввести повторно.
* Если пользователь вводит число два раза подряд, то он получает сообщение об ошибке и может ввести повторно.
* Приложение корректно обрабатывает ситуацию некорректного ввода.
